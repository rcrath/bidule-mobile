Bidule layout for live usage.  Has a zillion vsts and parameter links to my specific plugins and controllers, but may be useful to someone.

The idea is that there are five meta groups that take care of the routing. Sources, tones, Amps&Drums, loops, and time based. the last four each have a 16x16 matrix that can take any of sixteen outputs from the previous group and route it to any of its sixteen outputs.  the output of one group is the input to the next, so if something comes out channel 9 on one group it goes into channel 9 on the next. after the matrix within each group except for the first, source, there is an effects chain of some sort (more on that below) before outputting to the next group.   The one exception is amps&drums, about which more below.

* group 1: Source.  Contains sound generators or inputs from external sound generators.  In practice this means things like guitar inputs, voice, midi in, or bass for example.  midi in is routed to a bunch of synths, same input for all soft synths. I also have a wacom drawing pen as an intrument input.  It feeds OSC to a dedicated simple monosynth with a filter.  There is no matrix, since there is no upstream group to route from.  Each instrument has its own dedicated channel.  In practice, There are not enough channels to run everything I want, so I moved the drum machines t the Amps section, which has extra slots.  this messes with the logic a little but works well in practice.  More on that below.  
* Group 2. Tones These are all tone and timbre shaping devices that do not mess with timing, so no delays or reverbs here.  Effects include various distortions, resonant comb filters, bit crushers, spectral dynamics processors (SoundHack stuff).  ANy output from group one can be processed by any channel or combination of channels in group two.  This holds for the rest of the groups as well, so I won;t repeat it.  In practice it means I can set the gutar to run through three parallel effects (everything is parallel), and simultaneously send the synth notes coming from guitar to trigger two of the synths, with one synth going through a bitcrusher, another going through the same bit crusher, a distortion, and a spectral compressor. One-to-one (and usually a channel or three is left as pass through), one-to-many, many-to-one, or many-to-many. this holds true down the line for the rest of the groups, so won't be repeated.
* Group 3. Amps&Drums.  Three amp sims can channel the same guitar to have three different tones without changing any settings on the amp sims. A convolution model of the inside of an acoustic guitar to take piezo inut and make it sound like it is coming from a guitar body.  It also has a simple pitch shifter set to mix in up one octave for a faux-twelve-string sound.  A couple of empty channels that I use for bass or vocals if playing with others and they want in, then five drum machines or loop players to handle percussion duties. Technically these are sound generators so belong in sources but I ran out of room there.  In practice this means no tone shapers, so I cludge that later by adding in a distortion just for the drums and having live cut, which besides its awesom breakbeat cutting abilities has a comb filter and a bit cruser in it, on a dedicated drum channel downstreaam that all the drums get run through.  More on that in the time based section.
* Group 4. Loopers.  This includes on-the-fly loopers that can record, playback, and manipulate incoming audion in some form or another.  The line between some of these and some of the granulators in the next group is fuzzy, but works in practice such that anything that you want to live loop with, where you turn the loop recording or overdubbing on or off on the fly, goes here.  If you have to pre-load the loops, it goes with the drums.  If it is always recording and playing back buffers in some form, it goes in the time based effects, where all the granulators are next to each other.
* group 5. time based.  Echoes, reverbs, and granulators all go here. two channels are set aside for the drums, all of which get routed to one or the other.  On channel has distortion wired in that can be turned off or on, and the other has livecut, so any of the beats can get passed through, distorted, or tracked by livecut.  You can also send drums to any of the delays or granulatoes which can work out great.  

The sixteen outputs go to a sixteen channel mixer, then to soundcard, with a tap for recording the stereo output as well.  

All of this would obviously overload the cpu if everything were turned on all the time, so the "gui" such as it is has on/off switches for each item and when an item is off, it is muted or bypassed (depending on the situation) thereby cutting out CPU usage to only what is actually making sound at any one time.  If a row of any group is off in the matrix, it automagically sets the devices in its chain to off.  turning on a device will route a default input and output.  I am still working on the implementation of this.  Downside of this is that cpu assignment fails because the matrices create processing conflicts.  In practice, while it is easy to overload the single core, I can run quite a bit of stuff and stay glitch free.  It does occasionally explode in my face though!
